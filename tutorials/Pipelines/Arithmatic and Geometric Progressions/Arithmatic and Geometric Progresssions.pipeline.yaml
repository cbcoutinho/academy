apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: generates-ap-and-gp-and-calculates-the-sum-and-rth-term-
  annotations: {pipelines.kubeflow.org/kfp_sdk_version: 1.2.0, pipelines.kubeflow.org/pipeline_compilation_time: '2021-02-24T18:53:54.732325',
    pipelines.kubeflow.org/pipeline_spec: '{"description": "Generates AP and GP and
      Calculates the Sum and ''r''th term", "inputs": [{"default": "0", "name": "in_first_term_ap",
      "optional": true, "type": "Float"}, {"default": "0", "name": "in_common_difference_ap",
      "optional": true, "type": "Float"}, {"default": "0", "name": "in_total_terms_ap",
      "optional": true, "type": "Integer"}, {"default": "0", "name": "in_rth_term_ap",
      "optional": true, "type": "Integer"}, {"default": "0", "name": "in_first_term_gp",
      "optional": true, "type": "Float"}, {"default": "0", "name": "in_common_ratio_gp",
      "optional": true, "type": "Float"}, {"default": "0", "name": "in_total_terms_gp",
      "optional": true, "type": "Integer"}, {"default": "0", "name": "in_rth_term_gp",
      "optional": true, "type": "Integer"}], "name": "Generates AP and GP and Calculates
      the Sum and rth term"}'}
  labels: {pipelines.kubeflow.org/kfp_sdk_version: 1.2.0}
spec:
  entrypoint: generates-ap-and-gp-and-calculates-the-sum-and-rth-term
  templates:
  - name: ap-rth-term
    container:
      args: [--a, '{{inputs.parameters.read-inputs-ap-a}}', --d, '{{inputs.parameters.read-inputs-ap-d}}',
        --r, '{{inputs.parameters.read-inputs-ap-r}}', '----output-paths', /tmp/outputs/Output/data]
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        echo -n "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def ap_rth_term(a, d, r):
            r_term = a + (r - 1) * d

            if r > 3:
                print("{}th term of AP is : {}".format(r, r_term))
            elif r == 2:
                print("{}nd term of AP is : {}".format(r, r_term))
            elif r == 1:
                print("{}st term of AP is : {}".format(r, r_term))

            return r_term

        def _serialize_float(float_value: float) -> str:
            if isinstance(float_value, str):
                return float_value
            if not isinstance(float_value, (float, int)):
                raise TypeError('Value "{}" has type "{}" instead of float.'.format(str(float_value), str(type(float_value))))
            return str(float_value)

        import argparse
        _parser = argparse.ArgumentParser(prog='Ap rth term', description='')
        _parser.add_argument("--a", dest="a", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--d", dest="d", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--r", dest="r", type=int, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = ap_rth_term(**_parsed_args)

        _outputs = [_outputs]

        _output_serializers = [
            _serialize_float,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    inputs:
      parameters:
      - {name: read-inputs-ap-a}
      - {name: read-inputs-ap-d}
      - {name: read-inputs-ap-r}
    outputs:
      artifacts:
      - {name: ap-rth-term-Output, path: /tmp/outputs/Output/data}
    metadata:
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--a", {"inputValue": "a"}, "--d", {"inputValue": "d"}, "--r",
          {"inputValue": "r"}, "----output-paths", {"outputPath": "Output"}], "command":
          ["sh", "-ec", "program_path=$(mktemp)\necho -n \"$0\" > \"$program_path\"\npython3
          -u \"$program_path\" \"$@\"\n", "def ap_rth_term(a, d, r):\n    r_term =
          a + (r - 1) * d\n\n    if r > 3:\n        print(\"{}th term of AP is : {}\".format(r,
          r_term))\n    elif r == 2:\n        print(\"{}nd term of AP is : {}\".format(r,
          r_term))\n    elif r == 1:\n        print(\"{}st term of AP is : {}\".format(r,
          r_term))\n\n    return r_term\n\ndef _serialize_float(float_value: float)
          -> str:\n    if isinstance(float_value, str):\n        return float_value\n    if
          not isinstance(float_value, (float, int)):\n        raise TypeError(''Value
          \"{}\" has type \"{}\" instead of float.''.format(str(float_value), str(type(float_value))))\n    return
          str(float_value)\n\nimport argparse\n_parser = argparse.ArgumentParser(prog=''Ap
          rth term'', description='''')\n_parser.add_argument(\"--a\", dest=\"a\",
          type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--d\",
          dest=\"d\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--r\",
          dest=\"r\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = ap_rth_term(**_parsed_args)\n\n_outputs
          = [_outputs]\n\n_output_serializers = [\n    _serialize_float,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "a", "type": "Float"}, {"name":
          "d", "type": "Float"}, {"name": "r", "type": "Integer"}], "name": "Ap rth
          term", "outputs": [{"name": "Output", "type": "Float"}]}', pipelines.kubeflow.org/component_ref: '{}',
        pipelines.kubeflow.org/arguments.parameters: '{"a": "{{inputs.parameters.read-inputs-ap-a}}",
          "d": "{{inputs.parameters.read-inputs-ap-d}}", "r": "{{inputs.parameters.read-inputs-ap-r}}"}'}
  - name: ap-series
    container:
      args: [--a, '{{inputs.parameters.read-inputs-ap-a}}', --d, '{{inputs.parameters.read-inputs-ap-d}}',
        --n, '{{inputs.parameters.read-inputs-ap-n}}', '----output-paths', /tmp/outputs/a/data,
        /tmp/outputs/d/data, /tmp/outputs/n/data, /tmp/outputs/ser/data]
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        echo -n "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def ap_series(
            a, d, n
        ):
            l = []
            for x in range(n):
                l.append(a + x * d)

            print(
                "First Term : {}\nCommon Difference : {}\nLength of Series : {}\nLast Term : {}".format(
                    a, d, n, l[-1]
                )
            )
            print("Series :")
            for x in l:
                print("{}  ".format(x), end=" ")

            return (a, d, n, l)

        def _serialize_float(float_value: float) -> str:
            if isinstance(float_value, str):
                return float_value
            if not isinstance(float_value, (float, int)):
                raise TypeError('Value "{}" has type "{}" instead of float.'.format(str(float_value), str(type(float_value))))
            return str(float_value)

        def _serialize_json(obj) -> str:
            if isinstance(obj, str):
                return obj
            import json
            def default_serializer(obj):
                if hasattr(obj, 'to_struct'):
                    return obj.to_struct()
                else:
                    raise TypeError("Object of type '%s' is not JSON serializable and does not have .to_struct() method." % obj.__class__.__name__)
            return json.dumps(obj, default=default_serializer, sort_keys=True)

        def _serialize_int(int_value: int) -> str:
            if isinstance(int_value, str):
                return int_value
            if not isinstance(int_value, int):
                raise TypeError('Value "{}" has type "{}" instead of int.'.format(str(int_value), str(type(int_value))))
            return str(int_value)

        import argparse
        _parser = argparse.ArgumentParser(prog='Ap series', description='')
        _parser.add_argument("--a", dest="a", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--d", dest="d", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--n", dest="n", type=int, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=4)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = ap_series(**_parsed_args)

        _output_serializers = [
            _serialize_float,
            _serialize_float,
            _serialize_int,
            _serialize_json,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    inputs:
      parameters:
      - {name: read-inputs-ap-a}
      - {name: read-inputs-ap-d}
      - {name: read-inputs-ap-n}
    outputs:
      parameters:
      - name: ap-series-ser
        valueFrom: {path: /tmp/outputs/ser/data}
      artifacts:
      - {name: ap-series-a, path: /tmp/outputs/a/data}
      - {name: ap-series-d, path: /tmp/outputs/d/data}
      - {name: ap-series-n, path: /tmp/outputs/n/data}
      - {name: ap-series-ser, path: /tmp/outputs/ser/data}
    metadata:
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--a", {"inputValue": "a"}, "--d", {"inputValue": "d"}, "--n",
          {"inputValue": "n"}, "----output-paths", {"outputPath": "a"}, {"outputPath":
          "d"}, {"outputPath": "n"}, {"outputPath": "ser"}], "command": ["sh", "-ec",
          "program_path=$(mktemp)\necho -n \"$0\" > \"$program_path\"\npython3 -u
          \"$program_path\" \"$@\"\n", "def ap_series(\n    a, d, n\n):\n    l = []\n    for
          x in range(n):\n        l.append(a + x * d)\n\n    print(\n        \"First
          Term : {}\\nCommon Difference : {}\\nLength of Series : {}\\nLast Term :
          {}\".format(\n            a, d, n, l[-1]\n        )\n    )\n    print(\"Series
          :\")\n    for x in l:\n        print(\"{}  \".format(x), end=\" \")\n\n    return
          (a, d, n, l)\n\ndef _serialize_float(float_value: float) -> str:\n    if
          isinstance(float_value, str):\n        return float_value\n    if not isinstance(float_value,
          (float, int)):\n        raise TypeError(''Value \"{}\" has type \"{}\" instead
          of float.''.format(str(float_value), str(type(float_value))))\n    return
          str(float_value)\n\ndef _serialize_json(obj) -> str:\n    if isinstance(obj,
          str):\n        return obj\n    import json\n    def default_serializer(obj):\n        if
          hasattr(obj, ''to_struct''):\n            return obj.to_struct()\n        else:\n            raise
          TypeError(\"Object of type ''%s'' is not JSON serializable and does not
          have .to_struct() method.\" % obj.__class__.__name__)\n    return json.dumps(obj,
          default=default_serializer, sort_keys=True)\n\ndef _serialize_int(int_value:
          int) -> str:\n    if isinstance(int_value, str):\n        return int_value\n    if
          not isinstance(int_value, int):\n        raise TypeError(''Value \"{}\"
          has type \"{}\" instead of int.''.format(str(int_value), str(type(int_value))))\n    return
          str(int_value)\n\nimport argparse\n_parser = argparse.ArgumentParser(prog=''Ap
          series'', description='''')\n_parser.add_argument(\"--a\", dest=\"a\", type=float,
          required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--d\",
          dest=\"d\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--n\",
          dest=\"n\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=4)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = ap_series(**_parsed_args)\n\n_output_serializers
          = [\n    _serialize_float,\n    _serialize_float,\n    _serialize_int,\n    _serialize_json,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "a", "type": "Float"}, {"name":
          "d", "type": "Float"}, {"name": "n", "type": "Integer"}], "name": "Ap series",
          "outputs": [{"name": "a", "type": "Float"}, {"name": "d", "type": "Float"},
          {"name": "n", "type": "Integer"}, {"name": "ser", "type": "JsonArray"}]}',
        pipelines.kubeflow.org/component_ref: '{}', pipelines.kubeflow.org/arguments.parameters: '{"a":
          "{{inputs.parameters.read-inputs-ap-a}}", "d": "{{inputs.parameters.read-inputs-ap-d}}",
          "n": "{{inputs.parameters.read-inputs-ap-n}}"}'}
  - name: ap-sum
    container:
      args: [--a, '{{inputs.parameters.read-inputs-ap-a}}', --d, '{{inputs.parameters.read-inputs-ap-d}}',
        --n, '{{inputs.parameters.read-inputs-ap-n}}', --ser, '{{inputs.parameters.ap-series-ser}}',
        '----output-paths', /tmp/outputs/Output/data]
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        echo -n "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def ap_sum(a, d, n, ser):

            sum_of_ap = n * (2 * a + (n - 1) * d) / 2
            print("Sum of the AP is: {}".format(sum_of_ap))
            return sum_of_ap

        def _serialize_float(float_value: float) -> str:
            if isinstance(float_value, str):
                return float_value
            if not isinstance(float_value, (float, int)):
                raise TypeError('Value "{}" has type "{}" instead of float.'.format(str(float_value), str(type(float_value))))
            return str(float_value)

        import json
        import argparse
        _parser = argparse.ArgumentParser(prog='Ap sum', description='')
        _parser.add_argument("--a", dest="a", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--d", dest="d", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--n", dest="n", type=int, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--ser", dest="ser", type=json.loads, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = ap_sum(**_parsed_args)

        _outputs = [_outputs]

        _output_serializers = [
            _serialize_float,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    inputs:
      parameters:
      - {name: ap-series-ser}
      - {name: read-inputs-ap-a}
      - {name: read-inputs-ap-d}
      - {name: read-inputs-ap-n}
    outputs:
      artifacts:
      - {name: ap-sum-Output, path: /tmp/outputs/Output/data}
    metadata:
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--a", {"inputValue": "a"}, "--d", {"inputValue": "d"}, "--n",
          {"inputValue": "n"}, "--ser", {"inputValue": "ser"}, "----output-paths",
          {"outputPath": "Output"}], "command": ["sh", "-ec", "program_path=$(mktemp)\necho
          -n \"$0\" > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n", "def
          ap_sum(a, d, n, ser):\n\n    sum_of_ap = n * (2 * a + (n - 1) * d) / 2\n    print(\"Sum
          of the AP is: {}\".format(sum_of_ap))\n    return sum_of_ap\n\ndef _serialize_float(float_value:
          float) -> str:\n    if isinstance(float_value, str):\n        return float_value\n    if
          not isinstance(float_value, (float, int)):\n        raise TypeError(''Value
          \"{}\" has type \"{}\" instead of float.''.format(str(float_value), str(type(float_value))))\n    return
          str(float_value)\n\nimport json\nimport argparse\n_parser = argparse.ArgumentParser(prog=''Ap
          sum'', description='''')\n_parser.add_argument(\"--a\", dest=\"a\", type=float,
          required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--d\",
          dest=\"d\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--n\",
          dest=\"n\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--ser\",
          dest=\"ser\", type=json.loads, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = ap_sum(**_parsed_args)\n\n_outputs
          = [_outputs]\n\n_output_serializers = [\n    _serialize_float,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "a", "type": "Float"}, {"name":
          "d", "type": "Float"}, {"name": "n", "type": "Integer"}, {"name": "ser",
          "type": "JsonArray"}], "name": "Ap sum", "outputs": [{"name": "Output",
          "type": "Float"}]}', pipelines.kubeflow.org/component_ref: '{}', pipelines.kubeflow.org/arguments.parameters: '{"a":
          "{{inputs.parameters.read-inputs-ap-a}}", "d": "{{inputs.parameters.read-inputs-ap-d}}",
          "n": "{{inputs.parameters.read-inputs-ap-n}}", "ser": "{{inputs.parameters.ap-series-ser}}"}'}
  - name: generates-ap-and-gp-and-calculates-the-sum-and-rth-term
    dag:
      tasks:
      - name: ap-rth-term
        template: ap-rth-term
        dependencies: [read-inputs-ap]
        arguments:
          parameters:
          - {name: read-inputs-ap-a, value: '{{tasks.read-inputs-ap.outputs.parameters.read-inputs-ap-a}}'}
          - {name: read-inputs-ap-d, value: '{{tasks.read-inputs-ap.outputs.parameters.read-inputs-ap-d}}'}
          - {name: read-inputs-ap-r, value: '{{tasks.read-inputs-ap.outputs.parameters.read-inputs-ap-r}}'}
      - name: ap-series
        template: ap-series
        dependencies: [read-inputs-ap]
        arguments:
          parameters:
          - {name: read-inputs-ap-a, value: '{{tasks.read-inputs-ap.outputs.parameters.read-inputs-ap-a}}'}
          - {name: read-inputs-ap-d, value: '{{tasks.read-inputs-ap.outputs.parameters.read-inputs-ap-d}}'}
          - {name: read-inputs-ap-n, value: '{{tasks.read-inputs-ap.outputs.parameters.read-inputs-ap-n}}'}
      - name: ap-sum
        template: ap-sum
        dependencies: [ap-series, read-inputs-ap]
        arguments:
          parameters:
          - {name: ap-series-ser, value: '{{tasks.ap-series.outputs.parameters.ap-series-ser}}'}
          - {name: read-inputs-ap-a, value: '{{tasks.read-inputs-ap.outputs.parameters.read-inputs-ap-a}}'}
          - {name: read-inputs-ap-d, value: '{{tasks.read-inputs-ap.outputs.parameters.read-inputs-ap-d}}'}
          - {name: read-inputs-ap-n, value: '{{tasks.read-inputs-ap.outputs.parameters.read-inputs-ap-n}}'}
      - name: gp-rth-term
        template: gp-rth-term
        dependencies: [read-inputs-gp]
        arguments:
          parameters:
          - {name: read-inputs-gp-a, value: '{{tasks.read-inputs-gp.outputs.parameters.read-inputs-gp-a}}'}
          - {name: read-inputs-gp-d, value: '{{tasks.read-inputs-gp.outputs.parameters.read-inputs-gp-d}}'}
          - {name: read-inputs-gp-r, value: '{{tasks.read-inputs-gp.outputs.parameters.read-inputs-gp-r}}'}
      - name: gp-series
        template: gp-series
        dependencies: [read-inputs-gp]
        arguments:
          parameters:
          - {name: read-inputs-gp-a, value: '{{tasks.read-inputs-gp.outputs.parameters.read-inputs-gp-a}}'}
          - {name: read-inputs-gp-d, value: '{{tasks.read-inputs-gp.outputs.parameters.read-inputs-gp-d}}'}
          - {name: read-inputs-gp-n, value: '{{tasks.read-inputs-gp.outputs.parameters.read-inputs-gp-n}}'}
      - name: gp-sum
        template: gp-sum
        dependencies: [gp-series, read-inputs-gp]
        arguments:
          parameters:
          - {name: gp-series-ser, value: '{{tasks.gp-series.outputs.parameters.gp-series-ser}}'}
          - {name: read-inputs-gp-a, value: '{{tasks.read-inputs-gp.outputs.parameters.read-inputs-gp-a}}'}
          - {name: read-inputs-gp-d, value: '{{tasks.read-inputs-gp.outputs.parameters.read-inputs-gp-d}}'}
          - {name: read-inputs-gp-n, value: '{{tasks.read-inputs-gp.outputs.parameters.read-inputs-gp-n}}'}
      - {name: read-inputs-ap, template: read-inputs-ap}
      - {name: read-inputs-gp, template: read-inputs-gp}
  - name: gp-rth-term
    container:
      args: [--a, '{{inputs.parameters.read-inputs-gp-a}}', --d, '{{inputs.parameters.read-inputs-gp-d}}',
        --r, '{{inputs.parameters.read-inputs-gp-r}}', '----output-paths', /tmp/outputs/Output/data]
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        echo -n "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def gp_rth_term(a, d, r):
            r_term = a * pow(d, (r - 1))

            if r > 3:
                print("{}th term of GP is : {}".format(r, r_term))
            elif r == 2:
                print("{}nd term of GP is : {}".format(r, r_term))
            elif r == 1:
                print("{}st term of GP is : {}".format(r, r_term))

            return r_term

        def _serialize_float(float_value: float) -> str:
            if isinstance(float_value, str):
                return float_value
            if not isinstance(float_value, (float, int)):
                raise TypeError('Value "{}" has type "{}" instead of float.'.format(str(float_value), str(type(float_value))))
            return str(float_value)

        import argparse
        _parser = argparse.ArgumentParser(prog='Gp rth term', description='')
        _parser.add_argument("--a", dest="a", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--d", dest="d", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--r", dest="r", type=int, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = gp_rth_term(**_parsed_args)

        _outputs = [_outputs]

        _output_serializers = [
            _serialize_float,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    inputs:
      parameters:
      - {name: read-inputs-gp-a}
      - {name: read-inputs-gp-d}
      - {name: read-inputs-gp-r}
    outputs:
      artifacts:
      - {name: gp-rth-term-Output, path: /tmp/outputs/Output/data}
    metadata:
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--a", {"inputValue": "a"}, "--d", {"inputValue": "d"}, "--r",
          {"inputValue": "r"}, "----output-paths", {"outputPath": "Output"}], "command":
          ["sh", "-ec", "program_path=$(mktemp)\necho -n \"$0\" > \"$program_path\"\npython3
          -u \"$program_path\" \"$@\"\n", "def gp_rth_term(a, d, r):\n    r_term =
          a * pow(d, (r - 1))\n\n    if r > 3:\n        print(\"{}th term of GP is
          : {}\".format(r, r_term))\n    elif r == 2:\n        print(\"{}nd term of
          GP is : {}\".format(r, r_term))\n    elif r == 1:\n        print(\"{}st
          term of GP is : {}\".format(r, r_term))\n\n    return r_term\n\ndef _serialize_float(float_value:
          float) -> str:\n    if isinstance(float_value, str):\n        return float_value\n    if
          not isinstance(float_value, (float, int)):\n        raise TypeError(''Value
          \"{}\" has type \"{}\" instead of float.''.format(str(float_value), str(type(float_value))))\n    return
          str(float_value)\n\nimport argparse\n_parser = argparse.ArgumentParser(prog=''Gp
          rth term'', description='''')\n_parser.add_argument(\"--a\", dest=\"a\",
          type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--d\",
          dest=\"d\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--r\",
          dest=\"r\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = gp_rth_term(**_parsed_args)\n\n_outputs
          = [_outputs]\n\n_output_serializers = [\n    _serialize_float,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "a", "type": "Float"}, {"name":
          "d", "type": "Float"}, {"name": "r", "type": "Integer"}], "name": "Gp rth
          term", "outputs": [{"name": "Output", "type": "Float"}]}', pipelines.kubeflow.org/component_ref: '{}',
        pipelines.kubeflow.org/arguments.parameters: '{"a": "{{inputs.parameters.read-inputs-gp-a}}",
          "d": "{{inputs.parameters.read-inputs-gp-d}}", "r": "{{inputs.parameters.read-inputs-gp-r}}"}'}
  - name: gp-series
    container:
      args: [--a, '{{inputs.parameters.read-inputs-gp-a}}', --d, '{{inputs.parameters.read-inputs-gp-d}}',
        --n, '{{inputs.parameters.read-inputs-gp-n}}', '----output-paths', /tmp/outputs/a/data,
        /tmp/outputs/d/data, /tmp/outputs/n/data, /tmp/outputs/ser/data]
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        echo -n "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def gp_series(
            a, d, n
        ):
            l = []
            for x in range(n):
                l.append(a * pow(d, x))

            print(
                "First Term : {}\nCommon Ratio : {}\nLength of Series : {}\nLast Term : {}".format(
                    a, d, n, l[-1]
                )
            )
            print("Series :")

            for x in l:
                print("{}  ".format(x), end=" ")

            return (a, d, n, l)

        def _serialize_float(float_value: float) -> str:
            if isinstance(float_value, str):
                return float_value
            if not isinstance(float_value, (float, int)):
                raise TypeError('Value "{}" has type "{}" instead of float.'.format(str(float_value), str(type(float_value))))
            return str(float_value)

        def _serialize_json(obj) -> str:
            if isinstance(obj, str):
                return obj
            import json
            def default_serializer(obj):
                if hasattr(obj, 'to_struct'):
                    return obj.to_struct()
                else:
                    raise TypeError("Object of type '%s' is not JSON serializable and does not have .to_struct() method." % obj.__class__.__name__)
            return json.dumps(obj, default=default_serializer, sort_keys=True)

        def _serialize_int(int_value: int) -> str:
            if isinstance(int_value, str):
                return int_value
            if not isinstance(int_value, int):
                raise TypeError('Value "{}" has type "{}" instead of int.'.format(str(int_value), str(type(int_value))))
            return str(int_value)

        import argparse
        _parser = argparse.ArgumentParser(prog='Gp series', description='')
        _parser.add_argument("--a", dest="a", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--d", dest="d", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--n", dest="n", type=int, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=4)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = gp_series(**_parsed_args)

        _output_serializers = [
            _serialize_float,
            _serialize_float,
            _serialize_int,
            _serialize_json,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    inputs:
      parameters:
      - {name: read-inputs-gp-a}
      - {name: read-inputs-gp-d}
      - {name: read-inputs-gp-n}
    outputs:
      parameters:
      - name: gp-series-ser
        valueFrom: {path: /tmp/outputs/ser/data}
      artifacts:
      - {name: gp-series-a, path: /tmp/outputs/a/data}
      - {name: gp-series-d, path: /tmp/outputs/d/data}
      - {name: gp-series-n, path: /tmp/outputs/n/data}
      - {name: gp-series-ser, path: /tmp/outputs/ser/data}
    metadata:
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--a", {"inputValue": "a"}, "--d", {"inputValue": "d"}, "--n",
          {"inputValue": "n"}, "----output-paths", {"outputPath": "a"}, {"outputPath":
          "d"}, {"outputPath": "n"}, {"outputPath": "ser"}], "command": ["sh", "-ec",
          "program_path=$(mktemp)\necho -n \"$0\" > \"$program_path\"\npython3 -u
          \"$program_path\" \"$@\"\n", "def gp_series(\n    a, d, n\n):\n    l = []\n    for
          x in range(n):\n        l.append(a * pow(d, x))\n\n    print(\n        \"First
          Term : {}\\nCommon Ratio : {}\\nLength of Series : {}\\nLast Term : {}\".format(\n            a,
          d, n, l[-1]\n        )\n    )\n    print(\"Series :\")\n\n    for x in l:\n        print(\"{}  \".format(x),
          end=\" \")\n\n    return (a, d, n, l)\n\ndef _serialize_float(float_value:
          float) -> str:\n    if isinstance(float_value, str):\n        return float_value\n    if
          not isinstance(float_value, (float, int)):\n        raise TypeError(''Value
          \"{}\" has type \"{}\" instead of float.''.format(str(float_value), str(type(float_value))))\n    return
          str(float_value)\n\ndef _serialize_json(obj) -> str:\n    if isinstance(obj,
          str):\n        return obj\n    import json\n    def default_serializer(obj):\n        if
          hasattr(obj, ''to_struct''):\n            return obj.to_struct()\n        else:\n            raise
          TypeError(\"Object of type ''%s'' is not JSON serializable and does not
          have .to_struct() method.\" % obj.__class__.__name__)\n    return json.dumps(obj,
          default=default_serializer, sort_keys=True)\n\ndef _serialize_int(int_value:
          int) -> str:\n    if isinstance(int_value, str):\n        return int_value\n    if
          not isinstance(int_value, int):\n        raise TypeError(''Value \"{}\"
          has type \"{}\" instead of int.''.format(str(int_value), str(type(int_value))))\n    return
          str(int_value)\n\nimport argparse\n_parser = argparse.ArgumentParser(prog=''Gp
          series'', description='''')\n_parser.add_argument(\"--a\", dest=\"a\", type=float,
          required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--d\",
          dest=\"d\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--n\",
          dest=\"n\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=4)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = gp_series(**_parsed_args)\n\n_output_serializers
          = [\n    _serialize_float,\n    _serialize_float,\n    _serialize_int,\n    _serialize_json,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "a", "type": "Float"}, {"name":
          "d", "type": "Float"}, {"name": "n", "type": "Integer"}], "name": "Gp series",
          "outputs": [{"name": "a", "type": "Float"}, {"name": "d", "type": "Float"},
          {"name": "n", "type": "Integer"}, {"name": "ser", "type": "JsonArray"}]}',
        pipelines.kubeflow.org/component_ref: '{}', pipelines.kubeflow.org/arguments.parameters: '{"a":
          "{{inputs.parameters.read-inputs-gp-a}}", "d": "{{inputs.parameters.read-inputs-gp-d}}",
          "n": "{{inputs.parameters.read-inputs-gp-n}}"}'}
  - name: gp-sum
    container:
      args: [--a, '{{inputs.parameters.read-inputs-gp-a}}', --d, '{{inputs.parameters.read-inputs-gp-d}}',
        --n, '{{inputs.parameters.read-inputs-gp-n}}', --ser, '{{inputs.parameters.gp-series-ser}}',
        '----output-paths', /tmp/outputs/Output/data]
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        echo -n "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def gp_sum(a, d, n, ser):

            sum_of_gp = a * (1 - pow(d, n)) / (1 - d)
            print("Sum of the GP is : {}".format(sum_of_gp))
            return sum_of_gp

        def _serialize_float(float_value: float) -> str:
            if isinstance(float_value, str):
                return float_value
            if not isinstance(float_value, (float, int)):
                raise TypeError('Value "{}" has type "{}" instead of float.'.format(str(float_value), str(type(float_value))))
            return str(float_value)

        import json
        import argparse
        _parser = argparse.ArgumentParser(prog='Gp sum', description='')
        _parser.add_argument("--a", dest="a", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--d", dest="d", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--n", dest="n", type=int, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--ser", dest="ser", type=json.loads, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = gp_sum(**_parsed_args)

        _outputs = [_outputs]

        _output_serializers = [
            _serialize_float,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    inputs:
      parameters:
      - {name: gp-series-ser}
      - {name: read-inputs-gp-a}
      - {name: read-inputs-gp-d}
      - {name: read-inputs-gp-n}
    outputs:
      artifacts:
      - {name: gp-sum-Output, path: /tmp/outputs/Output/data}
    metadata:
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--a", {"inputValue": "a"}, "--d", {"inputValue": "d"}, "--n",
          {"inputValue": "n"}, "--ser", {"inputValue": "ser"}, "----output-paths",
          {"outputPath": "Output"}], "command": ["sh", "-ec", "program_path=$(mktemp)\necho
          -n \"$0\" > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n", "def
          gp_sum(a, d, n, ser):\n\n    sum_of_gp = a * (1 - pow(d, n)) / (1 - d)\n    print(\"Sum
          of the GP is : {}\".format(sum_of_gp))\n    return sum_of_gp\n\ndef _serialize_float(float_value:
          float) -> str:\n    if isinstance(float_value, str):\n        return float_value\n    if
          not isinstance(float_value, (float, int)):\n        raise TypeError(''Value
          \"{}\" has type \"{}\" instead of float.''.format(str(float_value), str(type(float_value))))\n    return
          str(float_value)\n\nimport json\nimport argparse\n_parser = argparse.ArgumentParser(prog=''Gp
          sum'', description='''')\n_parser.add_argument(\"--a\", dest=\"a\", type=float,
          required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--d\",
          dest=\"d\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--n\",
          dest=\"n\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--ser\",
          dest=\"ser\", type=json.loads, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = gp_sum(**_parsed_args)\n\n_outputs
          = [_outputs]\n\n_output_serializers = [\n    _serialize_float,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "a", "type": "Float"}, {"name":
          "d", "type": "Float"}, {"name": "n", "type": "Integer"}, {"name": "ser",
          "type": "JsonArray"}], "name": "Gp sum", "outputs": [{"name": "Output",
          "type": "Float"}]}', pipelines.kubeflow.org/component_ref: '{}', pipelines.kubeflow.org/arguments.parameters: '{"a":
          "{{inputs.parameters.read-inputs-gp-a}}", "d": "{{inputs.parameters.read-inputs-gp-d}}",
          "n": "{{inputs.parameters.read-inputs-gp-n}}", "ser": "{{inputs.parameters.gp-series-ser}}"}'}
  - name: read-inputs-ap
    container:
      args: [--first-term, '0', --difference, '0', --number-of-terms, '0', --find-rth-term,
        '0', '----output-paths', /tmp/outputs/a/data, /tmp/outputs/d/data, /tmp/outputs/n/data,
        /tmp/outputs/r/data]
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        echo -n "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def read_inputs_ap(
            first_term, difference, number_of_terms, find_rth_term
        ):
            a = first_term
            d = difference
            n = number_of_terms
            r = find_rth_term
            return (a, d, n, r)

        def _serialize_float(float_value: float) -> str:
            if isinstance(float_value, str):
                return float_value
            if not isinstance(float_value, (float, int)):
                raise TypeError('Value "{}" has type "{}" instead of float.'.format(str(float_value), str(type(float_value))))
            return str(float_value)

        def _serialize_int(int_value: int) -> str:
            if isinstance(int_value, str):
                return int_value
            if not isinstance(int_value, int):
                raise TypeError('Value "{}" has type "{}" instead of int.'.format(str(int_value), str(type(int_value))))
            return str(int_value)

        import argparse
        _parser = argparse.ArgumentParser(prog='Read inputs ap', description='')
        _parser.add_argument("--first-term", dest="first_term", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--difference", dest="difference", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--number-of-terms", dest="number_of_terms", type=int, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--find-rth-term", dest="find_rth_term", type=int, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=4)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = read_inputs_ap(**_parsed_args)

        _output_serializers = [
            _serialize_float,
            _serialize_float,
            _serialize_int,
            _serialize_int,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    outputs:
      parameters:
      - name: read-inputs-ap-a
        valueFrom: {path: /tmp/outputs/a/data}
      - name: read-inputs-ap-d
        valueFrom: {path: /tmp/outputs/d/data}
      - name: read-inputs-ap-n
        valueFrom: {path: /tmp/outputs/n/data}
      - name: read-inputs-ap-r
        valueFrom: {path: /tmp/outputs/r/data}
      artifacts:
      - {name: read-inputs-ap-a, path: /tmp/outputs/a/data}
      - {name: read-inputs-ap-d, path: /tmp/outputs/d/data}
      - {name: read-inputs-ap-n, path: /tmp/outputs/n/data}
      - {name: read-inputs-ap-r, path: /tmp/outputs/r/data}
    metadata:
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--first-term", {"inputValue": "first_term"}, "--difference",
          {"inputValue": "difference"}, "--number-of-terms", {"inputValue": "number_of_terms"},
          "--find-rth-term", {"inputValue": "find_rth_term"}, "----output-paths",
          {"outputPath": "a"}, {"outputPath": "d"}, {"outputPath": "n"}, {"outputPath":
          "r"}], "command": ["sh", "-ec", "program_path=$(mktemp)\necho -n \"$0\"
          > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n", "def read_inputs_ap(\n    first_term,
          difference, number_of_terms, find_rth_term\n):\n    a = first_term\n    d
          = difference\n    n = number_of_terms\n    r = find_rth_term\n    return
          (a, d, n, r)\n\ndef _serialize_float(float_value: float) -> str:\n    if
          isinstance(float_value, str):\n        return float_value\n    if not isinstance(float_value,
          (float, int)):\n        raise TypeError(''Value \"{}\" has type \"{}\" instead
          of float.''.format(str(float_value), str(type(float_value))))\n    return
          str(float_value)\n\ndef _serialize_int(int_value: int) -> str:\n    if isinstance(int_value,
          str):\n        return int_value\n    if not isinstance(int_value, int):\n        raise
          TypeError(''Value \"{}\" has type \"{}\" instead of int.''.format(str(int_value),
          str(type(int_value))))\n    return str(int_value)\n\nimport argparse\n_parser
          = argparse.ArgumentParser(prog=''Read inputs ap'', description='''')\n_parser.add_argument(\"--first-term\",
          dest=\"first_term\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--difference\",
          dest=\"difference\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--number-of-terms\",
          dest=\"number_of_terms\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--find-rth-term\",
          dest=\"find_rth_term\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=4)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = read_inputs_ap(**_parsed_args)\n\n_output_serializers
          = [\n    _serialize_float,\n    _serialize_float,\n    _serialize_int,\n    _serialize_int,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "first_term", "type": "Float"},
          {"name": "difference", "type": "Float"}, {"name": "number_of_terms", "type":
          "Integer"}, {"name": "find_rth_term", "type": "Integer"}], "name": "Read
          inputs ap", "outputs": [{"name": "a", "type": "Float"}, {"name": "d", "type":
          "Float"}, {"name": "n", "type": "Integer"}, {"name": "r", "type": "Integer"}]}',
        pipelines.kubeflow.org/component_ref: '{}', pipelines.kubeflow.org/arguments.parameters: '{"difference":
          "0", "find_rth_term": "0", "first_term": "0", "number_of_terms": "0"}'}
  - name: read-inputs-gp
    container:
      args: [--first-term, '0', --common-ratio, '0', --number-of-terms, '0', --find-rth-term,
        '0', '----output-paths', /tmp/outputs/a/data, /tmp/outputs/d/data, /tmp/outputs/n/data,
        /tmp/outputs/r/data]
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        echo -n "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - |
        def read_inputs_gp(
            first_term, common_ratio, number_of_terms, find_rth_term
        ):

            a = first_term
            d = common_ratio
            n = number_of_terms
            r = find_rth_term
            return (a, d, n, r)

        def _serialize_float(float_value: float) -> str:
            if isinstance(float_value, str):
                return float_value
            if not isinstance(float_value, (float, int)):
                raise TypeError('Value "{}" has type "{}" instead of float.'.format(str(float_value), str(type(float_value))))
            return str(float_value)

        def _serialize_int(int_value: int) -> str:
            if isinstance(int_value, str):
                return int_value
            if not isinstance(int_value, int):
                raise TypeError('Value "{}" has type "{}" instead of int.'.format(str(int_value), str(type(int_value))))
            return str(int_value)

        import argparse
        _parser = argparse.ArgumentParser(prog='Read inputs gp', description='')
        _parser.add_argument("--first-term", dest="first_term", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--common-ratio", dest="common_ratio", type=float, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--number-of-terms", dest="number_of_terms", type=int, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("--find-rth-term", dest="find_rth_term", type=int, required=True, default=argparse.SUPPRESS)
        _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=4)
        _parsed_args = vars(_parser.parse_args())
        _output_files = _parsed_args.pop("_output_paths", [])

        _outputs = read_inputs_gp(**_parsed_args)

        _output_serializers = [
            _serialize_float,
            _serialize_float,
            _serialize_int,
            _serialize_int,

        ]

        import os
        for idx, output_file in enumerate(_output_files):
            try:
                os.makedirs(os.path.dirname(output_file))
            except OSError:
                pass
            with open(output_file, 'w') as f:
                f.write(_output_serializers[idx](_outputs[idx]))
      image: python:3.7
    outputs:
      parameters:
      - name: read-inputs-gp-a
        valueFrom: {path: /tmp/outputs/a/data}
      - name: read-inputs-gp-d
        valueFrom: {path: /tmp/outputs/d/data}
      - name: read-inputs-gp-n
        valueFrom: {path: /tmp/outputs/n/data}
      - name: read-inputs-gp-r
        valueFrom: {path: /tmp/outputs/r/data}
      artifacts:
      - {name: read-inputs-gp-a, path: /tmp/outputs/a/data}
      - {name: read-inputs-gp-d, path: /tmp/outputs/d/data}
      - {name: read-inputs-gp-n, path: /tmp/outputs/n/data}
      - {name: read-inputs-gp-r, path: /tmp/outputs/r/data}
    metadata:
      annotations: {pipelines.kubeflow.org/component_spec: '{"implementation": {"container":
          {"args": ["--first-term", {"inputValue": "first_term"}, "--common-ratio",
          {"inputValue": "common_ratio"}, "--number-of-terms", {"inputValue": "number_of_terms"},
          "--find-rth-term", {"inputValue": "find_rth_term"}, "----output-paths",
          {"outputPath": "a"}, {"outputPath": "d"}, {"outputPath": "n"}, {"outputPath":
          "r"}], "command": ["sh", "-ec", "program_path=$(mktemp)\necho -n \"$0\"
          > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n", "def read_inputs_gp(\n    first_term,
          common_ratio, number_of_terms, find_rth_term\n):\n\n    a = first_term\n    d
          = common_ratio\n    n = number_of_terms\n    r = find_rth_term\n    return
          (a, d, n, r)\n\ndef _serialize_float(float_value: float) -> str:\n    if
          isinstance(float_value, str):\n        return float_value\n    if not isinstance(float_value,
          (float, int)):\n        raise TypeError(''Value \"{}\" has type \"{}\" instead
          of float.''.format(str(float_value), str(type(float_value))))\n    return
          str(float_value)\n\ndef _serialize_int(int_value: int) -> str:\n    if isinstance(int_value,
          str):\n        return int_value\n    if not isinstance(int_value, int):\n        raise
          TypeError(''Value \"{}\" has type \"{}\" instead of int.''.format(str(int_value),
          str(type(int_value))))\n    return str(int_value)\n\nimport argparse\n_parser
          = argparse.ArgumentParser(prog=''Read inputs gp'', description='''')\n_parser.add_argument(\"--first-term\",
          dest=\"first_term\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--common-ratio\",
          dest=\"common_ratio\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--number-of-terms\",
          dest=\"number_of_terms\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--find-rth-term\",
          dest=\"find_rth_term\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
          dest=\"_output_paths\", type=str, nargs=4)\n_parsed_args = vars(_parser.parse_args())\n_output_files
          = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = read_inputs_gp(**_parsed_args)\n\n_output_serializers
          = [\n    _serialize_float,\n    _serialize_float,\n    _serialize_int,\n    _serialize_int,\n\n]\n\nimport
          os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
          OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
          "image": "python:3.7"}}, "inputs": [{"name": "first_term", "type": "Float"},
          {"name": "common_ratio", "type": "Float"}, {"name": "number_of_terms", "type":
          "Integer"}, {"name": "find_rth_term", "type": "Integer"}], "name": "Read
          inputs gp", "outputs": [{"name": "a", "type": "Float"}, {"name": "d", "type":
          "Float"}, {"name": "n", "type": "Integer"}, {"name": "r", "type": "Integer"}]}',
        pipelines.kubeflow.org/component_ref: '{}', pipelines.kubeflow.org/arguments.parameters: '{"common_ratio":
          "0", "find_rth_term": "0", "first_term": "0", "number_of_terms": "0"}'}
  arguments:
    parameters:
    - {name: in_first_term_ap, value: '0'}
    - {name: in_common_difference_ap, value: '0'}
    - {name: in_total_terms_ap, value: '0'}
    - {name: in_rth_term_ap, value: '0'}
    - {name: in_first_term_gp, value: '0'}
    - {name: in_common_ratio_gp, value: '0'}
    - {name: in_total_terms_gp, value: '0'}
    - {name: in_rth_term_gp, value: '0'}
  serviceAccountName: pipeline-runner
